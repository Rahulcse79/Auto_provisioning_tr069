_b56â€.x([["parseXmlDeclaration",()=>parseXmlDeclaration],["parseAttrs",()=>parseAttrs],["decodeEntities",()=>decodeEntities],["encodeEntities",()=>encodeEntities],["parseXml",()=>parseXml]]);/**
 * Copyright 2013-2019  GenieACS Inc.
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
const CHAR_SINGLE_QUOTE = 39;
const CHAR_DOUBLE_QUOTE = 34;
const CHAR_LESS_THAN = 60;
const CHAR_GREATER_THAN = 62;
const CHAR_COLON = 58;
const CHAR_SPACE = 32;
const CHAR_TAB = 9;
const CHAR_CR = 13;
const CHAR_LF = 10;
const CHAR_SLASH = 47;
const CHAR_EXMARK = 33;
const CHAR_QMARK = 63;
const CHAR_EQUAL = 61;
const STATE_LESS_THAN = 1;
const STATE_SINGLE_QUOTE = 2;
const STATE_DOUBLE_QUOTE = 3;
       function parseXmlDeclaration(buffer) {
    const encodings = ["utf16le", "utf8", "latin1", "ascii"];
    for (const enc of encodings) {
        let str = buffer.toString(enc, 0, 150);
        if (str.startsWith("<?xml")) {
            str = str.slice(0, str.indexOf("?>"));
            try {
                return parseAttrs(str.slice(5));
            }
            catch (err) {
                // Ignore
            }
        }
    }
    return null;
}
       function parseAttrs(string) {
    const attrs = [];
    const len = string.length;
    let state = 0;
    let name = "";
    let namespace = "";
    let localName = "";
    let idx = 0;
    let colonIdx = 0;
    for (let i = 0; i < len; ++i) {
        const c = string.charCodeAt(i);
        switch (c) {
            case CHAR_SINGLE_QUOTE:
            case CHAR_DOUBLE_QUOTE:
                if (state === c) {
                    state = 0;
                    if (name) {
                        const value = string.slice(idx + 1, i);
                        const e = {
                            name: name,
                            namespace: namespace,
                            localName: localName,
                            value: value,
                        };
                        attrs.push(e);
                        name = "";
                        idx = i + 1;
                    }
                }
                else {
                    state = c;
                    idx = i;
                }
                continue;
            case CHAR_COLON:
                if (state)
                    continue;
                if (idx >= colonIdx)
                    colonIdx = i;
                continue;
            case CHAR_EQUAL:
                if (state)
                    continue;
                if (name)
                    throw new Error(`Unexpected character at ${i}`);
                name = string.slice(idx, i).trim();
                // TODO validate name
                if (colonIdx > idx) {
                    namespace = string.slice(idx, colonIdx).trim();
                    localName = string.slice(colonIdx + 1, i).trim();
                }
                else {
                    namespace = "";
                    localName = name;
                }
        }
    }
    if (name)
        throw new Error(`Attribute must have value at ${idx}`);
    const tail = string.slice(idx);
    if (tail.trim())
        throw new Error(`Unexpected string at ${len - tail.length}`);
    return attrs;
}
       function decodeEntities(string) {
    return string.replace(/&[0-9a-z#]+;/gi, (match) => {
        switch (match) {
            case "&quot;":
                return '"';
            case "&amp;":
                return "&";
            case "&apos;":
                return "'";
            case "&lt;":
                return "<";
            case "&gt;":
                return ">";
            default:
                if (match.startsWith("&#x")) {
                    const str = match.slice(3, -1).toLowerCase();
                    const n = parseInt(str, 16);
                    if (str.endsWith(n.toString(16)))
                        return String.fromCharCode(n);
                }
                else if (match.startsWith("&#")) {
                    const str = match.slice(2, -1);
                    const n = parseInt(str);
                    if (str.endsWith(n.toString()))
                        return String.fromCharCode(n);
                }
        }
        return match;
    });
}
       function encodeEntities(string) {
    const entities = {
        "&": "&amp;",
        '"': "&quot;",
        "'": "&apos;",
        "<": "&lt;",
        ">": "&gt;",
    };
    return string.replace(/[&"'<>]/g, (m) => entities[m]);
}
       function parseXml(string) {
    const len = string.length;
    let state1 = 0;
    let state1Index = 0;
    let state2 = 0;
    let state2Index = 0;
    const root = {
        name: "root",
        namespace: "",
        localName: "root",
        attrs: "",
        text: "",
        bodyIndex: 0,
        children: [],
    };
    const stack = [root];
    for (let i = 0; i < len; ++i) {
        switch (string.charCodeAt(i)) {
            case CHAR_SINGLE_QUOTE:
                switch (state1 & 0xff) {
                    case STATE_SINGLE_QUOTE:
                        state1 = state2;
                        state1Index = state2Index;
                        state2 = 0;
                        continue;
                    case STATE_LESS_THAN:
                        state2 = state1;
                        state2Index = state1Index;
                        state1 = STATE_SINGLE_QUOTE;
                        state1Index = i;
                        continue;
                }
                continue;
            case CHAR_DOUBLE_QUOTE:
                switch (state1 & 0xff) {
                    case STATE_DOUBLE_QUOTE:
                        state1 = state2;
                        state1Index = state2Index;
                        state2 = 0;
                        continue;
                    case STATE_LESS_THAN:
                        state2 = state1;
                        state2Index = state1Index;
                        state1 = STATE_DOUBLE_QUOTE;
                        state1Index = i;
                        continue;
                }
                continue;
            case CHAR_LESS_THAN:
                if ((state1 & 0xff) === 0) {
                    state2 = state1;
                    state2Index = state1Index;
                    state1 = STATE_LESS_THAN;
                    state1Index = i;
                }
                continue;
            case CHAR_COLON:
                if ((state1 & 0xff) === STATE_LESS_THAN) {
                    const colonIndex = (state1 >> 8) & 0xff;
                    if (colonIndex === 0)
                        state1 ^= ((i - state1Index) & 0xff) << 8;
                }
                continue;
            case CHAR_SPACE:
            case CHAR_TAB:
            case CHAR_CR:
            case CHAR_LF:
                if ((state1 & 0xff) === STATE_LESS_THAN) {
                    const wsIndex = (state1 >> 16) & 0xff;
                    if (wsIndex === 0)
                        state1 ^= ((i - state1Index) & 0xff) << 16;
                }
                continue;
            case CHAR_GREATER_THAN:
                if ((state1 & 0xff) === STATE_LESS_THAN) {
                    const secondChar = string.charCodeAt(state1Index + 1);
                    const wsIndex = (state1 >> 16) & 0xff;
                    let name, colonIndex, e, parent, selfClosing, localName, namespace;
                    switch (secondChar) {
                        case CHAR_SLASH:
                            e = stack.pop();
                            name =
                                wsIndex === 0
                                    ? string.slice(state1Index + 2, i)
                                    : string.slice(state1Index + 2, state1Index + wsIndex);
                            if (e.name !== name)
                                throw new Error(`Unmatched closing tag at ${i}`);
                            if (!e.children.length)
                                e.text = string.slice(e.bodyIndex, state1Index);
                            state1 = state2;
                            state1Index = state2Index;
                            state2 = 0;
                            continue;
                        case CHAR_EXMARK:
                            if (string.startsWith("![CDATA[", state1Index + 1)) {
                                if (string.endsWith("]]", i))
                                    throw new Error(`CDATA nodes are not supported at ${i}`);
                            }
                            else if (string.startsWith("!--", state1Index + 1)) {
                                // Comment node, ignore
                                if (string.endsWith("--", i)) {
                                    state1 = state2;
                                    state1Index = state2Index;
                                    state2 = 0;
                                }
                            }
                            continue;
                        case CHAR_QMARK:
                            if (string.charCodeAt(i - 1) === CHAR_QMARK) {
                                // XML declaration node, ignore
                                state1 = state2;
                                state1Index = state2Index;
                                state2 = 0;
                            }
                            continue;
                        default:
                            selfClosing = +(string.charCodeAt(i - 1) === CHAR_SLASH);
                            parent = stack[stack.length - 1];
                            colonIndex = (state1 >> 8) & 0xff;
                            name =
                                wsIndex === 0
                                    ? string.slice(state1Index + 1, i - selfClosing)
                                    : string.slice(state1Index + 1, state1Index + wsIndex);
                            if (colonIndex && (!wsIndex || colonIndex < wsIndex)) {
                                localName = name.slice(colonIndex);
                                namespace = name.slice(0, colonIndex - 1);
                            }
                            else {
                                localName = name;
                                namespace = "";
                            }
                            e = {
                                name: name,
                                namespace: namespace,
                                localName: localName,
                                attrs: wsIndex
                                    ? string.slice(state1Index + wsIndex + 1, i - selfClosing)
                                    : "",
                                text: "",
                                bodyIndex: i + 1,
                                children: [],
                            };
                            parent.children.push(e);
                            if (!selfClosing)
                                stack.push(e);
                            state1 = state2;
                            state1Index = state2Index;
                            state2 = 0;
                            continue;
                    }
                }
                continue;
        }
    }
    if (state1)
        throw new Error(`Unclosed token at ${state1Index}`);
    if (stack.length > 1) {
        const e = stack[stack.length - 1];
        throw new Error(`Unclosed XML element at ${e.bodyIndex}`);
    }
    if (!root.children.length)
        root.text = string;
    return root;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL2hvbWUvY29yYWwvRG9jdW1lbnRzL0dpdEh1Yi9BdXRvX3Byb3Zpc2lvbmluZ190cjA2OS9saWIveG1sLXBhcnNlci50cyIsInNvdXJjZXMiOlsiL2hvbWUvY29yYWwvRG9jdW1lbnRzL0dpdEh1Yi9BdXRvX3Byb3Zpc2lvbmluZ190cjA2OS9saWIveG1sLXBhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFFSCxNQUFNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztBQUM3QixNQUFNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztBQUM3QixNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDMUIsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFDN0IsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3RCLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUN0QixNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDbkIsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO0FBQ25CLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNuQixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDdEIsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUN0QixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFFdEIsTUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO0FBbUI3QixNQUFNLFVBQVUsbUJBQW1CLENBQUMsTUFBYztJQUNoRCxNQUFNLFNBQVMsR0FBcUIsQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMzRSxLQUFLLE1BQU0sR0FBRyxJQUFJLFNBQVMsRUFBRTtRQUMzQixJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDdkMsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzNCLEdBQUcsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDdEMsSUFBSTtnQkFDRixPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDakM7WUFBQyxPQUFPLEdBQUcsRUFBRTtnQkFDWixTQUFTO2FBQ1Y7U0FDRjtLQUNGO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBRUQsTUFBTSxVQUFVLFVBQVUsQ0FBQyxNQUFjO0lBQ3ZDLE1BQU0sS0FBSyxHQUFnQixFQUFFLENBQUM7SUFDOUIsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUUxQixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7SUFDZCxJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDbkIsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ25CLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNaLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1FBQzVCLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsUUFBUSxDQUFDLEVBQUU7WUFDVCxLQUFLLGlCQUFpQixDQUFDO1lBQ3ZCLEtBQUssaUJBQWlCO2dCQUNwQixJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUU7b0JBQ2YsS0FBSyxHQUFHLENBQUMsQ0FBQztvQkFDVixJQUFJLElBQUksRUFBRTt3QkFDUixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7d0JBQ3ZDLE1BQU0sQ0FBQyxHQUFHOzRCQUNSLElBQUksRUFBRSxJQUFJOzRCQUNWLFNBQVMsRUFBRSxTQUFTOzRCQUNwQixTQUFTLEVBQUUsU0FBUzs0QkFDcEIsS0FBSyxFQUFFLEtBQUs7eUJBQ2IsQ0FBQzt3QkFDRixLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNkLElBQUksR0FBRyxFQUFFLENBQUM7d0JBQ1YsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7cUJBQ2I7aUJBQ0Y7cUJBQU07b0JBQ0wsS0FBSyxHQUFHLENBQUMsQ0FBQztvQkFDVixHQUFHLEdBQUcsQ0FBQyxDQUFDO2lCQUNUO2dCQUNELFNBQVM7WUFFWCxLQUFLLFVBQVU7Z0JBQ2IsSUFBSSxLQUFLO29CQUFFLFNBQVM7Z0JBQ3BCLElBQUksR0FBRyxJQUFJLFFBQVE7b0JBQUUsUUFBUSxHQUFHLENBQUMsQ0FBQztnQkFDbEMsU0FBUztZQUVYLEtBQUssVUFBVTtnQkFDYixJQUFJLEtBQUs7b0JBQUUsU0FBUztnQkFDcEIsSUFBSSxJQUFJO29CQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQzFELElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDbkMscUJBQXFCO2dCQUNyQixJQUFJLFFBQVEsR0FBRyxHQUFHLEVBQUU7b0JBQ2xCLFNBQVMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQkFDL0MsU0FBUyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztpQkFDbEQ7cUJBQU07b0JBQ0wsU0FBUyxHQUFHLEVBQUUsQ0FBQztvQkFDZixTQUFTLEdBQUcsSUFBSSxDQUFDO2lCQUNsQjtTQUNKO0tBQ0Y7SUFFRCxJQUFJLElBQUk7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBRWpFLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1FBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBRTlFLE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVELE1BQU0sVUFBVSxjQUFjLENBQUMsTUFBYztJQUMzQyxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtRQUNoRCxRQUFRLEtBQUssRUFBRTtZQUNiLEtBQUssUUFBUTtnQkFDWCxPQUFPLEdBQUcsQ0FBQztZQUViLEtBQUssT0FBTztnQkFDVixPQUFPLEdBQUcsQ0FBQztZQUViLEtBQUssUUFBUTtnQkFDWCxPQUFPLEdBQUcsQ0FBQztZQUViLEtBQUssTUFBTTtnQkFDVCxPQUFPLEdBQUcsQ0FBQztZQUViLEtBQUssTUFBTTtnQkFDVCxPQUFPLEdBQUcsQ0FBQztZQUViO2dCQUNFLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDM0IsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFDN0MsTUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDNUIsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7d0JBQUUsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNqRTtxQkFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ2pDLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQy9CLE1BQU0sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDeEIsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQzt3QkFBRSxPQUFPLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQy9EO1NBQ0o7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELE1BQU0sVUFBVSxjQUFjLENBQUMsTUFBYztJQUMzQyxNQUFNLFFBQVEsR0FBRztRQUNmLEdBQUcsRUFBRSxPQUFPO1FBQ1osR0FBRyxFQUFFLFFBQVE7UUFDYixHQUFHLEVBQUUsUUFBUTtRQUNiLEdBQUcsRUFBRSxNQUFNO1FBQ1gsR0FBRyxFQUFFLE1BQU07S0FDWixDQUFDO0lBQ0YsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUVELE1BQU0sVUFBVSxRQUFRLENBQUMsTUFBYztJQUNyQyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzFCLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNmLElBQUksV0FBVyxHQUFHLENBQUMsQ0FBQztJQUNwQixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDZixJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7SUFFcEIsTUFBTSxJQUFJLEdBQVk7UUFDcEIsSUFBSSxFQUFFLE1BQU07UUFDWixTQUFTLEVBQUUsRUFBRTtRQUNiLFNBQVMsRUFBRSxNQUFNO1FBQ2pCLEtBQUssRUFBRSxFQUFFO1FBQ1QsSUFBSSxFQUFFLEVBQUU7UUFDUixTQUFTLEVBQUUsQ0FBQztRQUNaLFFBQVEsRUFBRSxFQUFFO0tBQ2IsQ0FBQztJQUVGLE1BQU0sS0FBSyxHQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFaEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRTtRQUM1QixRQUFRLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDNUIsS0FBSyxpQkFBaUI7Z0JBQ3BCLFFBQVEsTUFBTSxHQUFHLElBQUksRUFBRTtvQkFDckIsS0FBSyxrQkFBa0I7d0JBQ3JCLE1BQU0sR0FBRyxNQUFNLENBQUM7d0JBQ2hCLFdBQVcsR0FBRyxXQUFXLENBQUM7d0JBQzFCLE1BQU0sR0FBRyxDQUFDLENBQUM7d0JBQ1gsU0FBUztvQkFFWCxLQUFLLGVBQWU7d0JBQ2xCLE1BQU0sR0FBRyxNQUFNLENBQUM7d0JBQ2hCLFdBQVcsR0FBRyxXQUFXLENBQUM7d0JBQzFCLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQzt3QkFDNUIsV0FBVyxHQUFHLENBQUMsQ0FBQzt3QkFDaEIsU0FBUztpQkFDWjtnQkFDRCxTQUFTO1lBRVgsS0FBSyxpQkFBaUI7Z0JBQ3BCLFFBQVEsTUFBTSxHQUFHLElBQUksRUFBRTtvQkFDckIsS0FBSyxrQkFBa0I7d0JBQ3JCLE1BQU0sR0FBRyxNQUFNLENBQUM7d0JBQ2hCLFdBQVcsR0FBRyxXQUFXLENBQUM7d0JBQzFCLE1BQU0sR0FBRyxDQUFDLENBQUM7d0JBQ1gsU0FBUztvQkFFWCxLQUFLLGVBQWU7d0JBQ2xCLE1BQU0sR0FBRyxNQUFNLENBQUM7d0JBQ2hCLFdBQVcsR0FBRyxXQUFXLENBQUM7d0JBQzFCLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQzt3QkFDNUIsV0FBVyxHQUFHLENBQUMsQ0FBQzt3QkFDaEIsU0FBUztpQkFDWjtnQkFDRCxTQUFTO1lBRVgsS0FBSyxjQUFjO2dCQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDekIsTUFBTSxHQUFHLE1BQU0sQ0FBQztvQkFDaEIsV0FBVyxHQUFHLFdBQVcsQ0FBQztvQkFDMUIsTUFBTSxHQUFHLGVBQWUsQ0FBQztvQkFDekIsV0FBVyxHQUFHLENBQUMsQ0FBQztpQkFDakI7Z0JBQ0QsU0FBUztZQUVYLEtBQUssVUFBVTtnQkFDYixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLGVBQWUsRUFBRTtvQkFDdkMsTUFBTSxVQUFVLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO29CQUN4QyxJQUFJLFVBQVUsS0FBSyxDQUFDO3dCQUFFLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDakU7Z0JBQ0QsU0FBUztZQUVYLEtBQUssVUFBVSxDQUFDO1lBQ2hCLEtBQUssUUFBUSxDQUFDO1lBQ2QsS0FBSyxPQUFPLENBQUM7WUFDYixLQUFLLE9BQU87Z0JBQ1YsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxlQUFlLEVBQUU7b0JBQ3ZDLE1BQU0sT0FBTyxHQUFHLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDdEMsSUFBSSxPQUFPLEtBQUssQ0FBQzt3QkFBRSxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQy9EO2dCQUNELFNBQVM7WUFFWCxLQUFLLGlCQUFpQjtnQkFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxlQUFlLEVBQUU7b0JBQ3ZDLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUN0RCxNQUFNLE9BQU8sR0FBVyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7b0JBQzlDLElBQUksSUFBWSxFQUNkLFVBQWtCLEVBQ2xCLENBQVUsRUFDVixNQUFlLEVBQ2YsV0FBbUIsRUFDbkIsU0FBaUIsRUFDakIsU0FBaUIsQ0FBQztvQkFFcEIsUUFBUSxVQUFVLEVBQUU7d0JBQ2xCLEtBQUssVUFBVTs0QkFDYixDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDOzRCQUNoQixJQUFJO2dDQUNGLE9BQU8sS0FBSyxDQUFDO29DQUNYLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO29DQUNsQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQUcsQ0FBQyxFQUFFLFdBQVcsR0FBRyxPQUFPLENBQUMsQ0FBQzs0QkFDM0QsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUk7Z0NBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsRUFBRSxDQUFDLENBQUM7NEJBQ25ELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU07Z0NBQ3BCLENBQUMsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDOzRCQUNsRCxNQUFNLEdBQUcsTUFBTSxDQUFDOzRCQUNoQixXQUFXLEdBQUcsV0FBVyxDQUFDOzRCQUMxQixNQUFNLEdBQUcsQ0FBQyxDQUFDOzRCQUNYLFNBQVM7d0JBRVgsS0FBSyxXQUFXOzRCQUNkLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsV0FBVyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dDQUNsRCxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztvQ0FDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxFQUFFLENBQUMsQ0FBQzs2QkFDNUQ7aUNBQU0sSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Z0NBQ3BELHVCQUF1QjtnQ0FDdkIsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRTtvQ0FDNUIsTUFBTSxHQUFHLE1BQU0sQ0FBQztvQ0FDaEIsV0FBVyxHQUFHLFdBQVcsQ0FBQztvQ0FDMUIsTUFBTSxHQUFHLENBQUMsQ0FBQztpQ0FDWjs2QkFDRjs0QkFDRCxTQUFTO3dCQUVYLEtBQUssVUFBVTs0QkFDYixJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLFVBQVUsRUFBRTtnQ0FDM0MsK0JBQStCO2dDQUMvQixNQUFNLEdBQUcsTUFBTSxDQUFDO2dDQUNoQixXQUFXLEdBQUcsV0FBVyxDQUFDO2dDQUMxQixNQUFNLEdBQUcsQ0FBQyxDQUFDOzZCQUNaOzRCQUNELFNBQVM7d0JBRVg7NEJBQ0UsV0FBVyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxVQUFVLENBQUMsQ0FBQzs0QkFDekQsTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUNqQyxVQUFVLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDOzRCQUVsQyxJQUFJO2dDQUNGLE9BQU8sS0FBSyxDQUFDO29DQUNYLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQztvQ0FDaEQsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLENBQUMsRUFBRSxXQUFXLEdBQUcsT0FBTyxDQUFDLENBQUM7NEJBQzNELElBQUksVUFBVSxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxFQUFFO2dDQUNwRCxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztnQ0FDbkMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQzs2QkFDM0M7aUNBQU07Z0NBQ0wsU0FBUyxHQUFHLElBQUksQ0FBQztnQ0FDakIsU0FBUyxHQUFHLEVBQUUsQ0FBQzs2QkFDaEI7NEJBRUQsQ0FBQyxHQUFHO2dDQUNGLElBQUksRUFBRSxJQUFJO2dDQUNWLFNBQVMsRUFBRSxTQUFTO2dDQUNwQixTQUFTLEVBQUUsU0FBUztnQ0FDcEIsS0FBSyxFQUFFLE9BQU87b0NBQ1osQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLE9BQU8sR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQztvQ0FDMUQsQ0FBQyxDQUFDLEVBQUU7Z0NBQ04sSUFBSSxFQUFFLEVBQUU7Z0NBQ1IsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDO2dDQUNoQixRQUFRLEVBQUUsRUFBRTs2QkFDYixDQUFDOzRCQUNGLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUN4QixJQUFJLENBQUMsV0FBVztnQ0FBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUVoQyxNQUFNLEdBQUcsTUFBTSxDQUFDOzRCQUNoQixXQUFXLEdBQUcsV0FBVyxDQUFDOzRCQUMxQixNQUFNLEdBQUcsQ0FBQyxDQUFDOzRCQUNYLFNBQVM7cUJBQ1o7aUJBQ0Y7Z0JBQ0QsU0FBUztTQUNaO0tBQ0Y7SUFFRCxJQUFJLE1BQU07UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBRWhFLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDcEIsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7S0FDM0Q7SUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNO1FBQUUsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUM7SUFDOUMsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE5ICBHZW5pZUFDUyBJbmMuXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgR2VuaWVBQ1MuXG4gKlxuICogR2VuaWVBQ1MgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXNcbiAqIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZVxuICogTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBHZW5pZUFDUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCBHZW5pZUFDUy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuXG5jb25zdCBDSEFSX1NJTkdMRV9RVU9URSA9IDM5O1xuY29uc3QgQ0hBUl9ET1VCTEVfUVVPVEUgPSAzNDtcbmNvbnN0IENIQVJfTEVTU19USEFOID0gNjA7XG5jb25zdCBDSEFSX0dSRUFURVJfVEhBTiA9IDYyO1xuY29uc3QgQ0hBUl9DT0xPTiA9IDU4O1xuY29uc3QgQ0hBUl9TUEFDRSA9IDMyO1xuY29uc3QgQ0hBUl9UQUIgPSA5O1xuY29uc3QgQ0hBUl9DUiA9IDEzO1xuY29uc3QgQ0hBUl9MRiA9IDEwO1xuY29uc3QgQ0hBUl9TTEFTSCA9IDQ3O1xuY29uc3QgQ0hBUl9FWE1BUksgPSAzMztcbmNvbnN0IENIQVJfUU1BUksgPSA2MztcbmNvbnN0IENIQVJfRVFVQUwgPSA2MTtcblxuY29uc3QgU1RBVEVfTEVTU19USEFOID0gMTtcbmNvbnN0IFNUQVRFX1NJTkdMRV9RVU9URSA9IDI7XG5jb25zdCBTVEFURV9ET1VCTEVfUVVPVEUgPSAzO1xuXG5leHBvcnQgaW50ZXJmYWNlIEF0dHJpYnV0ZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgbmFtZXNwYWNlOiBzdHJpbmc7XG4gIGxvY2FsTmFtZTogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnQge1xuICBuYW1lOiBzdHJpbmc7XG4gIG5hbWVzcGFjZTogc3RyaW5nO1xuICBsb2NhbE5hbWU6IHN0cmluZztcbiAgYXR0cnM6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICBib2R5SW5kZXg6IG51bWJlcjtcbiAgY2hpbGRyZW46IEVsZW1lbnRbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWG1sRGVjbGFyYXRpb24oYnVmZmVyOiBCdWZmZXIpOiBBdHRyaWJ1dGVbXSB7XG4gIGNvbnN0IGVuY29kaW5nczogQnVmZmVyRW5jb2RpbmdbXSA9IFtcInV0ZjE2bGVcIiwgXCJ1dGY4XCIsIFwibGF0aW4xXCIsIFwiYXNjaWlcIl07XG4gIGZvciAoY29uc3QgZW5jIG9mIGVuY29kaW5ncykge1xuICAgIGxldCBzdHIgPSBidWZmZXIudG9TdHJpbmcoZW5jLCAwLCAxNTApO1xuICAgIGlmIChzdHIuc3RhcnRzV2l0aChcIjw/eG1sXCIpKSB7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgc3RyLmluZGV4T2YoXCI/PlwiKSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcGFyc2VBdHRycyhzdHIuc2xpY2UoNSkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElnbm9yZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXR0cnMoc3RyaW5nOiBzdHJpbmcpOiBBdHRyaWJ1dGVbXSB7XG4gIGNvbnN0IGF0dHJzOiBBdHRyaWJ1dGVbXSA9IFtdO1xuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuXG4gIGxldCBzdGF0ZSA9IDA7XG4gIGxldCBuYW1lID0gXCJcIjtcbiAgbGV0IG5hbWVzcGFjZSA9IFwiXCI7XG4gIGxldCBsb2NhbE5hbWUgPSBcIlwiO1xuICBsZXQgaWR4ID0gMDtcbiAgbGV0IGNvbG9uSWR4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGNvbnN0IGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgQ0hBUl9TSU5HTEVfUVVPVEU6XG4gICAgICBjYXNlIENIQVJfRE9VQkxFX1FVT1RFOlxuICAgICAgICBpZiAoc3RhdGUgPT09IGMpIHtcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3RyaW5nLnNsaWNlKGlkeCArIDEsIGkpO1xuICAgICAgICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgIGxvY2FsTmFtZTogbG9jYWxOYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXR0cnMucHVzaChlKTtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgaWR4ID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gYztcbiAgICAgICAgICBpZHggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIENIQVJfQ09MT046XG4gICAgICAgIGlmIChzdGF0ZSkgY29udGludWU7XG4gICAgICAgIGlmIChpZHggPj0gY29sb25JZHgpIGNvbG9uSWR4ID0gaTtcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGNhc2UgQ0hBUl9FUVVBTDpcbiAgICAgICAgaWYgKHN0YXRlKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG5hbWUpIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgJHtpfWApO1xuICAgICAgICBuYW1lID0gc3RyaW5nLnNsaWNlKGlkeCwgaSkudHJpbSgpO1xuICAgICAgICAvLyBUT0RPIHZhbGlkYXRlIG5hbWVcbiAgICAgICAgaWYgKGNvbG9uSWR4ID4gaWR4KSB7XG4gICAgICAgICAgbmFtZXNwYWNlID0gc3RyaW5nLnNsaWNlKGlkeCwgY29sb25JZHgpLnRyaW0oKTtcbiAgICAgICAgICBsb2NhbE5hbWUgPSBzdHJpbmcuc2xpY2UoY29sb25JZHggKyAxLCBpKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZXNwYWNlID0gXCJcIjtcbiAgICAgICAgICBsb2NhbE5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG5hbWUpIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlIG11c3QgaGF2ZSB2YWx1ZSBhdCAke2lkeH1gKTtcblxuICBjb25zdCB0YWlsID0gc3RyaW5nLnNsaWNlKGlkeCk7XG4gIGlmICh0YWlsLnRyaW0oKSkgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHN0cmluZyBhdCAke2xlbiAtIHRhaWwubGVuZ3RofWApO1xuXG4gIHJldHVybiBhdHRycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUVudGl0aWVzKHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8mWzAtOWEteiNdKzsvZ2ksIChtYXRjaCkgPT4ge1xuICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgIGNhc2UgXCImcXVvdDtcIjpcbiAgICAgICAgcmV0dXJuICdcIic7XG5cbiAgICAgIGNhc2UgXCImYW1wO1wiOlxuICAgICAgICByZXR1cm4gXCImXCI7XG5cbiAgICAgIGNhc2UgXCImYXBvcztcIjpcbiAgICAgICAgcmV0dXJuIFwiJ1wiO1xuXG4gICAgICBjYXNlIFwiJmx0O1wiOlxuICAgICAgICByZXR1cm4gXCI8XCI7XG5cbiAgICAgIGNhc2UgXCImZ3Q7XCI6XG4gICAgICAgIHJldHVybiBcIj5cIjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKG1hdGNoLnN0YXJ0c1dpdGgoXCImI3hcIikpIHtcbiAgICAgICAgICBjb25zdCBzdHIgPSBtYXRjaC5zbGljZSgzLCAtMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICAgICAgaWYgKHN0ci5lbmRzV2l0aChuLnRvU3RyaW5nKDE2KSkpIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoLnN0YXJ0c1dpdGgoXCImI1wiKSkge1xuICAgICAgICAgIGNvbnN0IHN0ciA9IG1hdGNoLnNsaWNlKDIsIC0xKTtcbiAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQoc3RyKTtcbiAgICAgICAgICBpZiAoc3RyLmVuZHNXaXRoKG4udG9TdHJpbmcoKSkpIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVFbnRpdGllcyhzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGVudGl0aWVzID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICBcIidcIjogXCImYXBvcztcIixcbiAgICBcIjxcIjogXCImbHQ7XCIsXG4gICAgXCI+XCI6IFwiJmd0O1wiLFxuICB9O1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1smXCInPD5dL2csIChtKSA9PiBlbnRpdGllc1ttXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVhtbChzdHJpbmc6IHN0cmluZyk6IEVsZW1lbnQge1xuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBsZXQgc3RhdGUxID0gMDtcbiAgbGV0IHN0YXRlMUluZGV4ID0gMDtcbiAgbGV0IHN0YXRlMiA9IDA7XG4gIGxldCBzdGF0ZTJJbmRleCA9IDA7XG5cbiAgY29uc3Qgcm9vdDogRWxlbWVudCA9IHtcbiAgICBuYW1lOiBcInJvb3RcIixcbiAgICBuYW1lc3BhY2U6IFwiXCIsXG4gICAgbG9jYWxOYW1lOiBcInJvb3RcIixcbiAgICBhdHRyczogXCJcIixcbiAgICB0ZXh0OiBcIlwiLFxuICAgIGJvZHlJbmRleDogMCxcbiAgICBjaGlsZHJlbjogW10sXG4gIH07XG5cbiAgY29uc3Qgc3RhY2s6IEVsZW1lbnRbXSA9IFtyb290XTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgc3dpdGNoIChzdHJpbmcuY2hhckNvZGVBdChpKSkge1xuICAgICAgY2FzZSBDSEFSX1NJTkdMRV9RVU9URTpcbiAgICAgICAgc3dpdGNoIChzdGF0ZTEgJiAweGZmKSB7XG4gICAgICAgICAgY2FzZSBTVEFURV9TSU5HTEVfUVVPVEU6XG4gICAgICAgICAgICBzdGF0ZTEgPSBzdGF0ZTI7XG4gICAgICAgICAgICBzdGF0ZTFJbmRleCA9IHN0YXRlMkluZGV4O1xuICAgICAgICAgICAgc3RhdGUyID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY2FzZSBTVEFURV9MRVNTX1RIQU46XG4gICAgICAgICAgICBzdGF0ZTIgPSBzdGF0ZTE7XG4gICAgICAgICAgICBzdGF0ZTJJbmRleCA9IHN0YXRlMUluZGV4O1xuICAgICAgICAgICAgc3RhdGUxID0gU1RBVEVfU0lOR0xFX1FVT1RFO1xuICAgICAgICAgICAgc3RhdGUxSW5kZXggPSBpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGNhc2UgQ0hBUl9ET1VCTEVfUVVPVEU6XG4gICAgICAgIHN3aXRjaCAoc3RhdGUxICYgMHhmZikge1xuICAgICAgICAgIGNhc2UgU1RBVEVfRE9VQkxFX1FVT1RFOlxuICAgICAgICAgICAgc3RhdGUxID0gc3RhdGUyO1xuICAgICAgICAgICAgc3RhdGUxSW5kZXggPSBzdGF0ZTJJbmRleDtcbiAgICAgICAgICAgIHN0YXRlMiA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgIGNhc2UgU1RBVEVfTEVTU19USEFOOlxuICAgICAgICAgICAgc3RhdGUyID0gc3RhdGUxO1xuICAgICAgICAgICAgc3RhdGUySW5kZXggPSBzdGF0ZTFJbmRleDtcbiAgICAgICAgICAgIHN0YXRlMSA9IFNUQVRFX0RPVUJMRV9RVU9URTtcbiAgICAgICAgICAgIHN0YXRlMUluZGV4ID0gaTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIENIQVJfTEVTU19USEFOOlxuICAgICAgICBpZiAoKHN0YXRlMSAmIDB4ZmYpID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUyID0gc3RhdGUxO1xuICAgICAgICAgIHN0YXRlMkluZGV4ID0gc3RhdGUxSW5kZXg7XG4gICAgICAgICAgc3RhdGUxID0gU1RBVEVfTEVTU19USEFOO1xuICAgICAgICAgIHN0YXRlMUluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgY2FzZSBDSEFSX0NPTE9OOlxuICAgICAgICBpZiAoKHN0YXRlMSAmIDB4ZmYpID09PSBTVEFURV9MRVNTX1RIQU4pIHtcbiAgICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gKHN0YXRlMSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaWYgKGNvbG9uSW5kZXggPT09IDApIHN0YXRlMSBePSAoKGkgLSBzdGF0ZTFJbmRleCkgJiAweGZmKSA8PCA4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIENIQVJfU1BBQ0U6XG4gICAgICBjYXNlIENIQVJfVEFCOlxuICAgICAgY2FzZSBDSEFSX0NSOlxuICAgICAgY2FzZSBDSEFSX0xGOlxuICAgICAgICBpZiAoKHN0YXRlMSAmIDB4ZmYpID09PSBTVEFURV9MRVNTX1RIQU4pIHtcbiAgICAgICAgICBjb25zdCB3c0luZGV4ID0gKHN0YXRlMSA+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGlmICh3c0luZGV4ID09PSAwKSBzdGF0ZTEgXj0gKChpIC0gc3RhdGUxSW5kZXgpICYgMHhmZikgPDwgMTY7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGNhc2UgQ0hBUl9HUkVBVEVSX1RIQU46XG4gICAgICAgIGlmICgoc3RhdGUxICYgMHhmZikgPT09IFNUQVRFX0xFU1NfVEhBTikge1xuICAgICAgICAgIGNvbnN0IHNlY29uZENoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChzdGF0ZTFJbmRleCArIDEpO1xuICAgICAgICAgIGNvbnN0IHdzSW5kZXg6IG51bWJlciA9IChzdGF0ZTEgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBsZXQgbmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgY29sb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgZTogRWxlbWVudCxcbiAgICAgICAgICAgIHBhcmVudDogRWxlbWVudCxcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nOiBudW1iZXIsXG4gICAgICAgICAgICBsb2NhbE5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogc3RyaW5nO1xuXG4gICAgICAgICAgc3dpdGNoIChzZWNvbmRDaGFyKSB7XG4gICAgICAgICAgICBjYXNlIENIQVJfU0xBU0g6XG4gICAgICAgICAgICAgIGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgbmFtZSA9XG4gICAgICAgICAgICAgICAgd3NJbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgPyBzdHJpbmcuc2xpY2Uoc3RhdGUxSW5kZXggKyAyLCBpKVxuICAgICAgICAgICAgICAgICAgOiBzdHJpbmcuc2xpY2Uoc3RhdGUxSW5kZXggKyAyLCBzdGF0ZTFJbmRleCArIHdzSW5kZXgpO1xuICAgICAgICAgICAgICBpZiAoZS5uYW1lICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5tYXRjaGVkIGNsb3NpbmcgdGFnIGF0ICR7aX1gKTtcbiAgICAgICAgICAgICAgaWYgKCFlLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICBlLnRleHQgPSBzdHJpbmcuc2xpY2UoZS5ib2R5SW5kZXgsIHN0YXRlMUluZGV4KTtcbiAgICAgICAgICAgICAgc3RhdGUxID0gc3RhdGUyO1xuICAgICAgICAgICAgICBzdGF0ZTFJbmRleCA9IHN0YXRlMkluZGV4O1xuICAgICAgICAgICAgICBzdGF0ZTIgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY2FzZSBDSEFSX0VYTUFSSzpcbiAgICAgICAgICAgICAgaWYgKHN0cmluZy5zdGFydHNXaXRoKFwiIVtDREFUQVtcIiwgc3RhdGUxSW5kZXggKyAxKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcuZW5kc1dpdGgoXCJdXVwiLCBpKSlcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ0RBVEEgbm9kZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYXQgJHtpfWApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5zdGFydHNXaXRoKFwiIS0tXCIsIHN0YXRlMUluZGV4ICsgMSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21tZW50IG5vZGUsIGlnbm9yZVxuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcuZW5kc1dpdGgoXCItLVwiLCBpKSkge1xuICAgICAgICAgICAgICAgICAgc3RhdGUxID0gc3RhdGUyO1xuICAgICAgICAgICAgICAgICAgc3RhdGUxSW5kZXggPSBzdGF0ZTJJbmRleDtcbiAgICAgICAgICAgICAgICAgIHN0YXRlMiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjYXNlIENIQVJfUU1BUks6XG4gICAgICAgICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpIC0gMSkgPT09IENIQVJfUU1BUkspIHtcbiAgICAgICAgICAgICAgICAvLyBYTUwgZGVjbGFyYXRpb24gbm9kZSwgaWdub3JlXG4gICAgICAgICAgICAgICAgc3RhdGUxID0gc3RhdGUyO1xuICAgICAgICAgICAgICAgIHN0YXRlMUluZGV4ID0gc3RhdGUySW5kZXg7XG4gICAgICAgICAgICAgICAgc3RhdGUyID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSArKHN0cmluZy5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gQ0hBUl9TTEFTSCk7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBjb2xvbkluZGV4ID0gKHN0YXRlMSA+PiA4KSAmIDB4ZmY7XG5cbiAgICAgICAgICAgICAgbmFtZSA9XG4gICAgICAgICAgICAgICAgd3NJbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgPyBzdHJpbmcuc2xpY2Uoc3RhdGUxSW5kZXggKyAxLCBpIC0gc2VsZkNsb3NpbmcpXG4gICAgICAgICAgICAgICAgICA6IHN0cmluZy5zbGljZShzdGF0ZTFJbmRleCArIDEsIHN0YXRlMUluZGV4ICsgd3NJbmRleCk7XG4gICAgICAgICAgICAgIGlmIChjb2xvbkluZGV4ICYmICghd3NJbmRleCB8fCBjb2xvbkluZGV4IDwgd3NJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBsb2NhbE5hbWUgPSBuYW1lLnNsaWNlKGNvbG9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IG5hbWUuc2xpY2UoMCwgY29sb25JbmRleCAtIDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2FsTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGUgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBsb2NhbE5hbWU6IGxvY2FsTmFtZSxcbiAgICAgICAgICAgICAgICBhdHRyczogd3NJbmRleFxuICAgICAgICAgICAgICAgICAgPyBzdHJpbmcuc2xpY2Uoc3RhdGUxSW5kZXggKyB3c0luZGV4ICsgMSwgaSAtIHNlbGZDbG9zaW5nKVxuICAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgYm9keUluZGV4OiBpICsgMSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGUpO1xuICAgICAgICAgICAgICBpZiAoIXNlbGZDbG9zaW5nKSBzdGFjay5wdXNoKGUpO1xuXG4gICAgICAgICAgICAgIHN0YXRlMSA9IHN0YXRlMjtcbiAgICAgICAgICAgICAgc3RhdGUxSW5kZXggPSBzdGF0ZTJJbmRleDtcbiAgICAgICAgICAgICAgc3RhdGUyID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZTEpIHRocm93IG5ldyBFcnJvcihgVW5jbG9zZWQgdG9rZW4gYXQgJHtzdGF0ZTFJbmRleH1gKTtcblxuICBpZiAoc3RhY2subGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuY2xvc2VkIFhNTCBlbGVtZW50IGF0ICR7ZS5ib2R5SW5kZXh9YCk7XG4gIH1cblxuICBpZiAoIXJvb3QuY2hpbGRyZW4ubGVuZ3RoKSByb290LnRleHQgPSBzdHJpbmc7XG4gIHJldHVybiByb290O1xufVxuIl19